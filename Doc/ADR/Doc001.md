ADR : 001

Titre : Choix des technologies backend et frontend

Statut : Accepté

Contexte :
Projet de Fullstack nécessitant une architecture robuste et maintenable. Le projet nécessite :
- Un backend solide avec un framework maîtrisé et bien structuré pour gérer les données de l'encyclopédie (samouraïs, batailles, clans, armes, styles de combat)
- Un frontend moderne et réactif pour offrir une expérience utilisateur fluide et interactive
- Une base technologique fiable et maintenable à long terme
- Une facilité de développement et de maintenance

Options : 

1. **Backend - Symfony (choisi)**
   - Framework PHP mature et structuré
   - Avantages : architecture MVC claire, composants réutilisables, grande communauté, documentation complète, intégration native avec Doctrine ORM
   - Inconvénients : courbe d'apprentissage initiale, peut être verbeux pour des projets simples

2. **Backend - Laravel**
   - Framework PHP populaire et expressif
   - Avantages : syntaxe élégante, développement rapide, écosystème riche
   - Inconvénients : structure moins stricte que Symfony, conventions parfois implicites

3. **Backend - Node.js (Express/NestJS)**
   - Runtime JavaScript côté serveur
   - Avantages : même langage que le frontend, performance élevée, écosystème npm
   - Inconvénients : moins maîtrisé dans l'équipe, écosystème moins mature pour certains cas d'usage

4. **Frontend - React (choisi)**
   - Bibliothèque JavaScript pour construire des interfaces utilisateur
   - Avantages : écosystème riche, grande communauté, flexibilité, performance optimale, composants réutilisables
   - Inconvénients : nécessite des choix supplémentaires (routing, state management), courbe d'apprentissage

5. **Frontend - Vue.js**
   - Framework JavaScript progressif
   - Avantages : courbe d'apprentissage douce, documentation excellente, syntaxe simple
   - Inconvénients : écosystème moins large que React, moins d'emplois sur le marché

6. **Frontend - Angular**
   - Framework JavaScript complet
   - Avantages : solution complète (routing, HTTP, etc.), typage fort avec TypeScript
   - Inconvénients : courbe d'apprentissage élevée, plus verbeux, surdimensionné pour ce projet

7. **Fullstack - Next.js**
   - Framework React avec rendu serveur
   - Avantages : solution complète, SEO optimisé, performance
   - Inconvénients : nécessite Node.js côté serveur, moins de flexibilité pour séparer backend/frontend

Decision : 

Adoption de **Symfony pour le backend** et **React pour le frontend** :
- **Backend** : Symfony (framework PHP, bien structuré, maîtrisé par l'équipe, intégration native avec Doctrine)
- **Frontend** : React (bibliothèque JavaScript moderne, écosystème riche, performance optimale, flexibilité)

Cette combinaison permet de bénéficier d'un backend solide et structuré avec Symfony, tout en ayant un frontend moderne et performant avec React. La séparation claire entre backend et frontend facilite le développement parallèle et la maintenance.

Conséquence : 

**Avantages :**
- Backend robuste : Symfony offre une architecture solide et des outils puissants (Doctrine, Security, Validator)
- Frontend moderne : React permet de créer des interfaces interactives et performantes
- Séparation des responsabilités : Backend et frontend peuvent évoluer indépendamment
- Écosystème mature : Les deux technologies bénéficient de grandes communautés et de nombreuses ressources
- Maintenabilité : Code structuré et conventions claires facilitent la maintenance à long terme

**Inconvénients à gérer :**
- Deux langages différents : PHP pour le backend, JavaScript/TypeScript pour le frontend (nécessite des compétences dans les deux)
- Configuration initiale : Mise en place de deux environnements de développement (PHP et Node.js)
- Communication API : Nécessité de définir clairement les contrats d'API entre backend et frontend

**Actions requises :**
- Installer et configurer Symfony avec les bundles nécessaires
- Configurer React avec les outils de build (Vite)
- Mettre en place la communication entre frontend et backend via API REST
- Définir les conventions de nommage et d'architecture pour chaque partie





ADR : 002

Titre : Choix de l'architecture monorepo

Statut : Accepté

Contexte :
Après avoir choisi Symfony pour le backend et React pour le frontend, il faut décider de l'organisation du code source. Le projet nécessite une gestion efficace pour coordonner les développements backend et frontend, faciliter le déploiement et la maintenance.

Les contraintes principales sont :
- Coordination entre backend et frontend : modifications souvent liées (nouvelle fonctionnalité = changements backend + frontend)
- Versioning : gestion des versions compatibles entre backend et frontend
- Déploiement : faciliter le déploiement de versions cohérentes
- Maintenance : simplifier la gestion du projet
- Partage de code : possibilité de partager des types, constantes, utilitaires

Options : 

1. **Architecture monorepo (choisie)**
   - Un seul dépôt Git contenant backend (Symfony) et frontend (React)
   - Avantages : gestion unifiée des versions, partage de code facilité, déploiements coordonnés, historique Git unique, traçabilité des modifications liées
   - Inconvénients : dépôt plus volumineux, nécessite une organisation claire des dossiers, CI/CD plus complexe

2. **Architecture multi-repo**
   - Dépôts Git séparés pour backend et frontend
   - Avantages : séparation claire des responsabilités, équipes indépendantes, dépôts plus légers
   - Inconvénients : gestion de versions complexe, synchronisation difficile entre les deux dépôts, duplication potentielle de code, traçabilité réduite

Decision : 

Adoption d'une architecture **monorepo** :
- **Structure** : Organisation claire des dossiers avec séparation backend/frontend dans le même dépôt
- **Backend** : Dossier `/Hagakure` pour Symfony
- **Frontend** : Dossier `/hagakure-front` pour React
- **Versioning unifié** : Toutes les modifications backend/frontend dans le même historique Git

Cette décision permet une meilleure coordination, un versioning unifié, et facilite la maintenance et le déploiement de l'application complète.

Conséquence : 

**Avantages :**
- Versioning unifié : toutes les modifications backend/frontend sont liées dans le même historique Git
- Déploiements coordonnés : possibilité de déployer des versions compatibles ensemble
- Partage de code : types TypeScript, constantes, utilitaires peuvent être partagés facilement
- Maintenance simplifiée : un seul dépôt à gérer, une seule configuration CI/CD
- Traçabilité : liens clairs entre modifications backend et frontend dans les commits
- Refactoring facilité : modifications qui touchent les deux parties dans un seul commit

**Inconvénients à gérer :**
- Taille du dépôt : nécessite une organisation claire (dossiers séparés backend/frontend)
- CI/CD : nécessite une configuration pour builder et tester les deux parties indépendamment
- Permissions : tous les développeurs ont accès à tout le code (peut être géré avec des branches)
- Clonage initial : dépôt plus volumineux à cloner

**Actions requises :**
- Structurer le dépôt avec des dossiers clairs (ex: `/Hagakure` pour backend, `/hagakure-front` pour frontend)
- Configurer les outils de build pour gérer les deux parties indépendamment
- Mettre en place des conventions de nommage et d'organisation
- Configurer le CI/CD pour builder et tester les deux parties séparément
- Documenter la structure du monorepo dans le README


ADR : 003

Titre : Choix de l'authentification JWT pour l'API

Statut : Accepté

Contexte :
L'application nécessite un système d'authentification pour permettre aux utilisateurs de créer un compte, se connecter, et accéder à des fonctionnalités réservées (gestion des favoris, profil utilisateur). L'architecture séparée entre backend Symfony (API REST) et frontend React nécessite une solution d'authentification stateless qui fonctionne bien avec les API REST.

Les contraintes principales sont :
- Architecture stateless : pas de session serveur à maintenir
- Compatibilité avec API REST : fonctionnement avec des requêtes HTTP standard
- Sécurité : protection des données utilisateur et des endpoints sensibles
- Scalabilité : solution qui fonctionne bien avec plusieurs serveurs/instances
- Simplicité d'implémentation : intégration avec Symfony et React

Options : 

1. **JWT (JSON Web Tokens) (choisie)**
   - Tokens signés contenant les informations de l'utilisateur
   - Avantages : stateless, scalable, standardisé, fonctionne bien avec les API REST, pas de stockage serveur nécessaire
   - Inconvénients : difficulté de révocation avant expiration, taille des tokens, nécessite une gestion sécurisée des clés secrètes

2. **Sessions PHP traditionnelles**
   - Utilisation des sessions natives de PHP/Symfony
   - Avantages : simple à implémenter, révocation facile, bien intégré à Symfony
   - Inconvénients : nécessite un stockage serveur (fichiers, Redis, base de données), pas idéal pour les API REST, problèmes de scalabilité

3. **API Keys**
   - Clés d'API simples pour chaque utilisateur
   - Avantages : très simple, pas de gestion de tokens
   - Inconvénients : moins sécurisé, pas de gestion d'expiration fine, révocation difficile

Decision : 

Adoption de l'**authentification JWT** pour l'API :
- **Stateless** : Pas de session serveur, chaque requête contient le token nécessaire
- **Standardisé** : Format JWT largement supporté et documenté
- **Scalable** : Fonctionne avec plusieurs instances backend sans partage de session
- **Intégration Symfony** : Utilisation de LexikJWTAuthenticationBundle pour la gestion des tokens
- **Sécurité** : Tokens signés avec clé secrète, expiration configurable, support du refresh token

Cette décision permet une authentification moderne, scalable et adaptée à une architecture API REST avec frontend séparé.

Conséquence : 

**Avantages :**
- Stateless : Pas besoin de stocker les sessions côté serveur, réduit la charge serveur
- Scalabilité : Facilite la mise à l'échelle horizontale (plusieurs serveurs backend)
- Standard REST : S'intègre naturellement avec les API REST (header Authorization)
- Performance : Pas de requêtes base de données pour vérifier la session à chaque requête
- Mobile-friendly : Fonctionne bien avec les applications mobiles futures
- CORS simplifié : Pas de gestion complexe des cookies cross-origin

**Inconvénients à gérer :**
- Révocation difficile : Un token valide reste valide jusqu'à expiration (solution : blacklist ou refresh tokens courts)
- Taille des tokens : Les tokens JWT peuvent être plus volumineux que les cookies de session
- Sécurité des clés : Nécessite une gestion sécurisée de la clé secrète (variables d'environnement)
- Pas de déconnexion immédiate : La déconnexion côté client ne révoque pas le token (acceptable pour ce projet)

**Actions requises :**
- Installer et configurer LexikJWTAuthenticationBundle dans Symfony
- Configurer la génération et la validation des tokens JWT
- Mettre en place les endpoints d'authentification (`/api/login`, `/api/register`)
- Implémenter la gestion du token côté React (stockage localStorage/sessionStorage)
- Ajouter l'intercepteur HTTP pour inclure le token dans les requêtes API
- Configurer la sécurité Symfony pour protéger les routes API avec JWT
- Mettre en place un système de refresh token si nécessaire
- Documenter l'utilisation de l'API d'authentification